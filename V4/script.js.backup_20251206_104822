// --- Configuration and Data ---
const LOCAL_STORAGE_KEY_TEAMS = 'quizTeams';
const LOCAL_STORAGE_KEY_QUESTION_STATUS = 'quizQuestionStatus';
const LOCAL_STORAGE_KEY_CURRENT_INDEX = 'quizCurrentIndex';
const LOCAL_STORAGE_KEY_ROUND_STATE = 'quizRoundStateV1';
const LOCAL_STORAGE_KEY_INDIVIDUALS = 'quizIndividualsV1';

// --- Image Handling Function ---
/**
 * Generates the local path for a question image.
 * NOTE: Ensure all image files (e.g., colombia_map.jpg, nigeria_flags.png)
 * are stored in a local directory named 'images' within your project root.
 *
 * @param {string} filename The name of the image file.
 * @returns {string} The relative path to the image.
 */
const getQuestionImage = (filename) => {
    return `images/${filename}`;
};

// Full set of quiz questions loaded from the user's document
// -------------------------------------------------------------------
const geographyQuestions = [
    // --- Round 1: Multiple Choice (1, 3, 5 Points) ---
    {
        id: "R1-MC-001",
        type: "multiple-choice",
        text: "以下哪个城市不是中国的四个直辖市之一？",
        options: ["A.上海", "B.天津", "C.重庆", "D.深圳"],
        answer: "D",
        points: 1,
        rationale: "中国四个直辖市是北京、上海、天津、重庆。深圳是经济特区，但不是直辖市。",
        img: null
    },
    {
        id: "R1-MC-002",
        type: "multiple-choice",
        text: "世界最长的河流是哪条？",
        options: ["A.亚马逊河", "B.尼罗河", "C.长江", "D.密西西比河"],
        answer: "B",
        points: 3,
        rationale: "尼罗河被普遍认为是世界最长的河流，但也有争议认为亚马逊河更长。在本测验中，我们以传统认知为准。",
        img: null
    },
    {
        id: "R1-MC-003",
        type: "multiple-choice",
        text: "哪个国家以其独特的袋鼠和考拉而闻名？",
        options: ["A.新西兰", "B.南非", "C.澳大利亚", "D.加拿大"],
        answer: "C",
        points: 5,
        rationale: "澳大利亚是袋鼠和考拉的自然栖息地。",
        img: null
    },
    {
        id: "R1-MC-004",
        type: "multiple-choice",
        text: "世界海拔最高的山峰是？",
        options: ["A.乔戈里峰 (K2)", "B.干城章嘉峰", "C.珠穆朗玛峰", "D.洛子峰"],
        answer: "C",
        points: 3,
        rationale: "珠穆朗玛峰是世界海拔最高的山峰。",
        img: null
    },
    {
        id: "R1-MC-005",
        type: "multiple-choice",
        text: "哪种香料是世界上最昂贵之一，通常以其重量计价？",
        options: ["A.肉桂", "B.藏红花 (Saffron)", "C.香草", "D.丁香"],
        answer: "B",
        points: 1,
        rationale: "藏红花因其采摘过程费时费力而成为世界上最昂贵的香料之一。",
        img: null
    },

    // --- Round 2: Team Speed (10 Points) ---
    {
        id: "R2-TS-001",
        type: "short-answer",
        text: "请问在2024年巴黎奥运会上，中国夺得了多少枚金牌？",
        answer: "40",
        points: 10,
        rationale: "2024年巴黎奥运会，中国体育代表团最终以40枚金牌、20枚银牌、23枚铜牌，位列金牌榜第一。",
        img: null
    },
    {
        id: "R2-TS-002",
        type: "short-answer",
        text: "请说出三个与中国相邻的内陆国家（不与海洋接壤）。",
        answer: "蒙古、阿富汗、尼泊尔、老挝、不丹、吉尔吉斯斯坦、塔吉克斯坦、哈萨克斯坦",
        points: 10,
        rationale: "与中国相邻的内陆国家包括：蒙古、阿富汗、尼泊尔、老挝、不丹、吉尔吉斯斯坦、塔吉克斯坦、哈萨克斯坦。",
        img: null
    },
    {
        id: "R2-TS-003",
        type: "short-answer",
        text: "图中是哪个南美洲国家的地图？（提示：以咖啡和生物多样性闻名）",
        answer: "哥伦比亚",
        points: 10,
        rationale: "这是哥伦比亚的地图。",
        img: getQuestionImage('colombia_map.jpg')
    },
    {
        id: "R2-TS-004",
        type: "short-answer",
        text: "请说出图中这个非洲国家的国旗上的两个主要颜色。（提示：人口最多的非洲国家之一）",
        answer: "绿、白",
        points: 10,
        rationale: "图中是尼日利亚国旗，主要颜色是绿色和白色。",
        img: getQuestionImage('nigeria_flags.png')
    },
    {
        id: "R2-TS-005",
        type: "short-answer",
        text: "以下哪部电影是由中国导演张艺谋执导的（只写电影名）：《霸王别姬》、《活着》、《卧虎藏龙》、或《红高粱》？",
        answer: "活着 或 红高粱",
        points: 10,
        rationale: "《活着》和《红高粱》是张艺谋的代表作。《霸王别姬》是陈凯歌执导，《卧虎藏龙》是李安执导。",
        img: null
    },

    // --- Round 3: Individual Questions (10, 15 Points) ---
    {
        id: "R3-IQ-001",
        type: "individual-sa",
        text: "请问'光年'是衡量什么物理量的单位？",
        answer: "距离",
        points: 10,
        rationale: "光年是天文学中用来表示距离的单位，指光在一年时间里行进的距离。",
        img: null
    },
    {
        id: "R3-IQ-002",
        type: "individual-mc",
        text: "人类最大的内分泌腺是哪个？",
        options: ["A.甲状腺", "B.肾上腺", "C.脑垂体", "D.胰腺"],
        answer: "A",
        points: 15,
        rationale: "甲状腺是人体最大的内分泌腺。",
        img: null
    },
    {
        id: "R3-IQ-003",
        type: "individual-sa",
        text: "哪个国家的首都是堪培拉？",
        answer: "澳大利亚",
        points: 10,
        rationale: "澳大利亚的首都是堪培拉，而非悉尼或墨尔本。",
        img: null
    },
    {
        id: "R3-IQ-004",
        type: "individual-mc",
        text: "在计算机科学中，'URL'代表什么？",
        options: ["A.Universal Resource Locator", "B.Uniform Radio Link", "C.Unified Resource Language", "D.Universal Reference Line"],
        answer: "A",
        points: 15,
        rationale: "URL代表 Universal Resource Locator（统一资源定位符）。",
        img: null
    },

    // --- Tiebreaker Round (5 Points) ---
    {
        id: "TB-001",
        type: "short-answer",
        text: "欧洲联盟有多少个成员国？",
        answer: "27",
        points: 5,
        rationale: "截至当前，欧洲联盟有27个成员国。",
        img: null
    }
    // -------------------------------------------------------------------
];

let currentQuestionIndex = -1; // -1 for welcome screen, 0 for first question
let teams = [];
let questionStatus = []; // Stores correct/incorrect/points for each team and question
let roundState = {
    isRound1Finished: false,
    isRound2Finished: false,
    isRound3Finished: false,
    eliminatedTeam1: null,
    eliminatedTeam2: null,
    eliminatedTeam3: null,
};
let individuals = {}; // Stores individual player scores: { teamId: { playerName: score } }

// --- Timer Variables ---
let timerInterval = null;
let timeRemaining = 10;
const DING_AUDIO = new Audio('audio/ding.mp3');

// --- Helper Functions ---

/**
 * Finds the index of the first question belonging to a specific round number.
 * @param {number} targetRoundNumber The round number (1, 2, 3, or 4 for Tiebreaker).
 * @returns {number} The index of the first question, or -1 if not found.
 */
function findFirstQuestionIndexForRound(targetRoundNumber) {
    let prefix;
    if (targetRoundNumber === 1) prefix = "R1-";
    else if (targetRoundNumber === 2) prefix = "R2-";
    else if (targetRoundNumber === 3) prefix = "R3-";
    else if (targetRoundNumber === 4) prefix = "TB-"; // Assuming round 4 is the tiebreaker
    else return -1; // Unknown round

    for (let i = 0; i < geographyQuestions.length; i++) {
        if (geographyQuestions[i].id.startsWith(prefix)) {
            return i;
        }
    }
    return -1; // Not found
}

// --- Data Persistence and Initialization ---

function saveTeams() {
    localStorage.setItem(LOCAL_STORAGE_KEY_TEAMS, JSON.stringify(teams));
}

function loadTeams() {
    const savedTeams = localStorage.getItem(LOCAL_STORAGE_KEY_TEAMS);
    if (savedTeams) {
        teams = JSON.parse(savedTeams);
    } else {
        // Initial setup for 5 teams
        teams = [{
            id: 'T1',
            name: '星辰队',
            score: 0,
            color: 'bg-indigo-600'
        },
        {
            id: 'T2',
            name: '银河队',
            score: 0,
            color: 'bg-teal-600'
        },
        {
            id: 'T3',
            name: '北极星队',
            score: 0,
            color: 'bg-yellow-600'
        },
        {
            id: 'T4',
            name: '流星队',
            score: 0,
            color: 'bg-pink-600'
        },
        {
            id: 'T5',
            name: '彗星队',
            score: 0,
            color: 'bg-green-600'
        },
        ];
        saveTeams();
    }
}

function saveQuestionStatus() {
    localStorage.setItem(LOCAL_STORAGE_KEY_QUESTION_STATUS, JSON.stringify(questionStatus));
}

function loadQuestionStatus() {
    const savedStatus = localStorage.getItem(LOCAL_STORAGE_KEY_QUESTION_STATUS);
    if (savedStatus) {
        questionStatus = JSON.parse(savedStatus);
    } else {
        // Initialize status for all questions and teams
        questionStatus = geographyQuestions.map(q => ({
            questionId: q.id,
            teams: teams.map(t => ({
                teamId: t.id,
                isCorrect: false,
                points: 0,
                applied: false
            }))
        }));
        saveQuestionStatus();
    }
}

function saveCurrentIndex() {
    localStorage.setItem(LOCAL_STORAGE_KEY_CURRENT_INDEX, currentQuestionIndex);
}

function loadCurrentIndex() {
    const savedIndex = localStorage.getItem(LOCAL_STORAGE_KEY_CURRENT_INDEX);
    currentQuestionIndex = savedIndex !== null ? parseInt(savedIndex) : -1;
}

function saveRoundState() {
    localStorage.setItem(LOCAL_STORAGE_KEY_ROUND_STATE, JSON.stringify(roundState));
}

function loadRoundState() {
    const savedState = localStorage.getItem(LOCAL_STORAGE_KEY_ROUND_STATE);
    if (savedState) {
        roundState = JSON.parse(savedState);
    } else {
        saveRoundState();
    }
}

function saveIndividuals() {
    localStorage.setItem(LOCAL_STORAGE_KEY_INDIVIDUALS, JSON.stringify(individuals));
}

function loadIndividuals() {
    const savedIndividuals = localStorage.getItem(LOCAL_STORAGE_KEY_INDIVIDUALS);
    if (savedIndividuals) {
        individuals = JSON.parse(savedIndividuals);
    } else {
        // Initialize individual scores structure
        teams.forEach(t => {
            individuals[t.id] = {
                'Player A': 0,
                'Player B': 0,
                'Player C': 0,
            };
        });
        saveIndividuals();
    }
}

function initializeQuestions() {
    // Only initialize questionStatus if it's completely empty or mismatched
    loadQuestionStatus();
    if (questionStatus.length !== geographyQuestions.length) {
        console.log("Reinitializing question status due to length mismatch.");
        questionStatus = geographyQuestions.map(q => ({
            questionId: q.id,
            teams: teams.map(t => ({
                teamId: t.id,
                isCorrect: false,
                points: 0,
                applied: false
            }))
        }));
        saveQuestionStatus();
    }
}


// --- Core Game Logic ---

/**
 * Calculates the total score for a given team.
 * @param {string} teamId The ID of the team.
 * @returns {number} The total score.
 */
function calculateTeamScore(teamId) {
    let score = 0;
    // Sum points from question status
    questionStatus.forEach(qStatus => {
        const teamStatus = qStatus.teams.find(t => t.teamId === teamId);
        if (teamStatus && teamStatus.applied) {
            score += teamStatus.points;
        }
    });

    // Add individual points (if applicable)
    if (individuals[teamId]) {
        score += Object.values(individuals[teamId]).reduce((sum, current) => sum + current, 0);
    }

    // Add bonus points from roundState (if applicable)
    if (roundState.isRound3Finished && teamId === 'T1') {
        score += 20; // Example: Bonus for the final round winner
    }
    // ... add other round bonuses here if needed ...

    return score;
}

/**
 * Applies the score for a specific question to a team.
 * @param {string} teamId The ID of the team.
 * @param {boolean} isCorrect Whether the answer was correct.
 * @param {number} questionIndex The index of the question.
 */
function applyScore(teamId, isCorrect, questionIndex) {
    const question = geographyQuestions[questionIndex];
    const qStatus = questionStatus[questionIndex];
    const teamStatus = qStatus.teams.find(t => t.teamId === teamId);

    if (teamStatus) {
        // Calculate points: full points for correct, 0 for incorrect/not answered
        const pointsAwarded = isCorrect ? question.points : 0;

        teamStatus.isCorrect = isCorrect;
        teamStatus.points = pointsAwarded;
        teamStatus.applied = true; // Mark as processed for this question

        // Update the main team score for live display
        const team = teams.find(t => t.id === teamId);
        if (team) {
            team.score = calculateTeamScore(teamId); // Recalculate full score
        }

        saveTeams();
        saveQuestionStatus();
        renderLeaderboard();
        renderQuestionPanel(questionIndex); // Re-render to update UI
    }
}

/**
 * Removes the score for a specific question from a team (reverts the points).
 * @param {string} teamId The ID of the team.
 * @param {number} questionIndex The index of the question.
 */
function removeScore(teamId, questionIndex) {
    const qStatus = questionStatus[questionIndex];
    const teamStatus = qStatus.teams.find(t => t.teamId === teamId);

    if (teamStatus && teamStatus.applied) {
        teamStatus.isCorrect = false;
        teamStatus.points = 0;
        teamStatus.applied = false; // Mark as not processed

        // Update the main team score for live display
        const team = teams.find(t => t.id === teamId);
        if (team) {
            team.score = calculateTeamScore(teamId); // Recalculate full score
        }

        saveTeams();
        saveQuestionStatus();
        renderLeaderboard();
        renderQuestionPanel(questionIndex); // Re-render to update UI
    }
}

/**
 * Handles the elimination logic and round transition.
 * @param {number} roundNumber The round that just finished (1, 2, or 3).
 */
function finishRound(roundNumber) {
    let nextQuestionIndex = -1;

    // Sort teams by score (descending)
    const sortedTeams = [...teams].sort((a, b) => b.score - a.score);
    // const eliminatedTeams = teams.filter(t => t.eliminated); // Unused

    if (roundNumber === 1 && !roundState.isRound1Finished) {
        // Round 1 Elimination: Eliminate 2 lowest-scoring teams
        let teamsToEliminate = sortedTeams.filter(t => !t.eliminated).slice(-2);

        if (teamsToEliminate.length > 0) {
            teamsToEliminate.forEach(team => {
                team.eliminated = true;
                console.log(`Team ${team.name} eliminated after Round 1.`);
            });
            roundState.eliminatedTeam1 = teamsToEliminate[0]?.id;
            roundState.eliminatedTeam2 = teamsToEliminate[1]?.id;
        }

        roundState.isRound1Finished = true;
        nextQuestionIndex = findFirstQuestionIndexForRound(2);
    } else if (roundNumber === 2 && !roundState.isRound2Finished) {
        // Round 2 Elimination: Eliminate 1 lowest-scoring team from the remaining 3
        let remainingTeams = sortedTeams.filter(t => !t.eliminated);
        let teamToEliminate = remainingTeams.slice(-1)[0];

        if (teamToEliminate) {
            teamToEliminate.eliminated = true;
            roundState.eliminatedTeam3 = teamToEliminate.id;
            console.log(`Team ${teamToEliminate.name} eliminated after Round 2.`);
        }

        roundState.isRound2Finished = true;
        nextQuestionIndex = findFirstQuestionIndexForRound(3);
    } else if (roundNumber === 3 && !roundState.isRound3Finished) {
        // Round 3: Apply Bonuses and transition to final screen/tiebreaker
        // Note: Bonuses are applied in calculateTeamScore (e.g., T1 gets +20)
        roundState.isRound3Finished = true;
        nextQuestionIndex = findFirstQuestionIndexForRound(4); // Jump to Tiebreaker (TB-001)

        // Ensure scores are recalculated to include bonuses
        teams.forEach(t => t.score = calculateTeamScore(t.id));

    } else {
        // Logic for repeated clicks or invalid round
        console.log(`Round ${roundNumber} already finished or invalid round number.`);
    }

    saveTeams();
    saveRoundState();
    renderLeaderboard();
    updateRoundStatusUI();

    // NEW LOGIC: Skip to the next round's first question
    if (nextQuestionIndex !== -1) {
        // Jump to the first question of the next round
        loadQuestion(nextQuestionIndex);
        console.log(`Finished Round ${roundNumber}. Skipping to the first question of Round ${roundNumber + 1} at index ${nextQuestionIndex}.`);
    } else {
        // If the next round is not found (e.g., after R3/Tiebreaker), stay on the current screen (or show a final screen)
        console.log(`Finished Round ${roundNumber}. No further rounds found or loaded.`);
    }
}


// --- Individual Score Management ---

/**
 * Adjusts an individual player's score.
 * @param {string} teamId The ID of the team.
 * @param {string} playerName The name of the player ('Player A', 'Player B', 'Player C').
 * @param {number} points The points to add/subtract.
 */
function adjustIndividualScore(teamId, playerName, points) {
    if (individuals[teamId] && individuals[teamId][playerName] !== undefined) {
        individuals[teamId][playerName] += points;
        saveIndividuals();

        // Recalculate team score
        const team = teams.find(t => t.id === teamId);
        if (team) {
            team.score = calculateTeamScore(t.id);
            saveTeams();
        }

        renderIndividualLeaderboard();
        renderLeaderboard();
    }
}

// --- UI Rendering Functions ---

/**
 * Renders the main leaderboard.
 */
function renderLeaderboard() {
    const leaderboardBody = document.getElementById('leaderboardBody');
    if (!leaderboardBody) return;

    // Sort teams by current score (descending)
    const sortedTeams = [...teams].sort((a, b) => b.score - a.score);

    leaderboardBody.innerHTML = sortedTeams.map((team, index) => {
        const eliminationClass = team.eliminated ? 'opacity-40 line-through' : '';
        const eliminatedTag = team.eliminated ? '<span class="ml-2 text-xs font-bold text-red-500">（淘汰）</span>' : '';
        return `
            <tr class="border-t border-gray-700 hover:bg-gray-700/50 ${eliminationClass}">
                <td class="py-2 px-4 text-center text-lg font-extrabold">${index + 1}</td>
                <td class="py-2 px-4 flex items-center">
                    <span class="w-3 h-3 ${team.color} rounded-full mr-2"></span>
                    <span class="font-semibold text-gray-100">${team.name}</span>
                    ${eliminatedTag}
                </td>
                <td class="py-2 px-4 text-right text-xl font-bold text-indigo-400">${team.score}</td>
            </tr>
        `;
    }).join('');
}

/**
 * Renders the individual player scoring adjustments.
 */
function renderIndividualLeaderboard() {
    const individualScoresContainer = document.getElementById('individualScores');
    if (!individualScoresContainer) return;

    const remainingTeams = teams.filter(t => !t.eliminated);

    individualScoresContainer.innerHTML = remainingTeams.map(team => {
        const teamIndividuals = individuals[team.id] || {};
        const totalIndividualScore = Object.values(teamIndividuals).reduce((sum, current) => sum + current, 0);

        const playersHtml = Object.keys(teamIndividuals).map(playerName => {
            const playerScore = teamIndividuals[playerName];
            return `
                <div class="flex justify-between items-center space-x-2 border-t border-gray-700 pt-1 mt-1">
                    <span class="text-xs text-gray-400">${playerName}</span>
                    <div class="flex items-center space-x-1">
                        <span class="text-sm font-semibold text-yellow-300 w-8 text-right">${playerScore}</span>
                        <button onclick="adjustIndividualScore('${team.id}', '${playerName}', 5)" class="text-green-400 hover:text-green-300 text-xs font-bold w-4 h-4 flex items-center justify-center rounded-full bg-gray-700">+</button>
                        <button onclick="adjustIndividualScore('${team.id}', '${playerName}', -5)" class="text-red-400 hover:text-red-300 text-xs font-bold w-4 h-4 flex items-center justify-center rounded-full bg-gray-700">-</button>
                    </div>
                </div>
            `;
        }).join('');

        return `
            <div class="p-3 bg-gray-800 rounded-lg shadow-inner">
                <h3 class="font-bold text-sm text-indigo-300 mb-2">${team.name} (个人总分: ${totalIndividualScore})</h3>
                ${playersHtml}
            </div>
        `;
    }).join('');
}


/**
 * Renders the start/next/prev buttons.
 * @param {number} questionIndex The index of the question to load.
 */
function renderQuestionNavigation(questionIndex) {
    const nextBtn = document.getElementById('nextQuestionBtn');
    const prevBtn = document.getElementById('prevQuestionBtn');
    const startBtn = document.getElementById('startQuizBtn');

    if (!nextBtn || !prevBtn || !startBtn) return;

    if (questionIndex === -1) {
        // Welcome/Start Screen
        startBtn.classList.remove('hidden');
        nextBtn.classList.add('hidden');
        prevBtn.classList.add('hidden');
        // Hide score buttons when on welcome screen
        document.getElementById('scoreAdjustmentControls').classList.add('hidden');
        document.getElementById('roundControls').classList.add('hidden');

    } else {
        // Question Screen
        startBtn.classList.add('hidden');
        document.getElementById('scoreAdjustmentControls').classList.remove('hidden');
        document.getElementById('roundControls').classList.remove('hidden');

        // Next Button Logic
        if (questionIndex < geographyQuestions.length - 1) {
            nextBtn.classList.remove('hidden');
            nextBtn.disabled = false;
            nextBtn.classList.remove('opacity-50', 'cursor-not-allowed');
        } else {
            nextBtn.disabled = true;
            nextBtn.classList.add('opacity-50', 'cursor-not-allowed');
        }

        // Previous Button Logic
        if (questionIndex > 0) {
            prevBtn.classList.remove('hidden');
            prevBtn.disabled = false;
            prevBtn.classList.remove('opacity-50', 'cursor-not-allowed');
        } else {
            prevBtn.disabled = true;
            prevBtn.classList.add('opacity-50', 'cursor-not-allowed');
        }
    }
}

/**
 * Renders the main question panel content.
 * @param {number} questionIndex The index of the question to load.
 */
function renderQuestionPanel(questionIndex) {
    const card = document.getElementById('questionCard');
    const questionPanel = document.getElementById('questionPanel');
    const controls = document.getElementById('scoreAdjustmentControls');

    if (questionIndex === -1) {
        // Welcome Screen
        card.innerHTML = `
            <h2 class="text-3xl font-bold text-center text-indigo-400 mb-4">欢迎来到 地动星河 总决赛</h2>
            <p class="text-lg text-center text-gray-300">
                请点击 '开始测验' 按钮加载第一个问题。
            </p>
            <p class="text-sm text-center mt-4 text-gray-500">
                当前保存状态: ${teams.length} 支队伍, ${geographyQuestions.length} 个问题.
            </p>
        `;
        // Hide score controls
        controls.classList.add('hidden');
        questionPanel.classList.add('hidden');
        card.style.backgroundColor = 'rgba(31, 41, 55, 0.8)'; // Dark background for welcome
        return;
    }

    const question = geographyQuestions[questionIndex];
    const qStatus = questionStatus[questionIndex];
    const currentRound = question.id.startsWith('R1') ? 1 : question.id.startsWith('R2') ? 2 : question.id.startsWith('R3') ? 3 : 4;

    // Show panel and controls
    questionPanel.classList.remove('hidden');
    controls.classList.remove('hidden');

    // Determine the base color based on the round
    let cardBgColor = 'rgba(31, 41, 55, 0.9)'; // Default dark
    let roundTextColor = 'text-indigo-400';
    if (currentRound === 1) {
        cardBgColor = 'rgba(79, 70, 229, 0.2)'; // Indigo focus
        roundTextColor = 'text-indigo-300';
    } else if (currentRound === 2) {
        cardBgColor = 'rgba(16, 185, 129, 0.2)'; // Teal focus
        roundTextColor = 'text-teal-300';
    } else if (currentRound === 3) {
        cardBgColor = 'rgba(234, 179, 8, 0.2)'; // Yellow focus
        roundTextColor = 'text-yellow-300';
    } else if (currentRound === 4) {
        cardBgColor = 'rgba(239, 68, 68, 0.2)'; // Red focus for tiebreaker
        roundTextColor = 'text-red-300';
    }
    card.style.backgroundColor = cardBgColor;


    // --- Question Content ---
    let questionContent = `<p class="text-lg font-semibold text-gray-300 mb-4">${question.text}</p>`;

    // Add image if available
    if (question.img) {
        questionContent += `<img src="${question.img}" alt="Question Image" class="max-h-60 max-w-full mx-auto my-4 rounded-lg shadow-lg object-contain border border-gray-700">`;
    }

    // Add options for multiple-choice
    if (question.type.includes('multiple-choice') && question.options) {
        questionContent += `<div class="mt-4 space-y-2">`;
        question.options.forEach(option => {
            questionContent += `<p class="text-gray-400 text-sm">${option}</p>`;
        });
        questionContent += `</div>`;
    }

    // Display the answer and rationale
    let answerContent = `
        <div class="mt-6 p-4 bg-gray-800 rounded-lg border-l-4 border-yellow-500">
            <h4 class="text-sm font-bold text-yellow-300">正确答案:</h4>
            <p class="text-2xl font-extrabold text-yellow-100 mt-1">${question.answer}</p>
        </div>
        <div class="mt-4 p-4 bg-gray-800 rounded-lg text-sm text-gray-400 border-l-4 border-gray-600">
            <h4 class="font-bold text-gray-300">解析:</h4>
            <p>${question.rationale}</p>
        </div>
    `;


    card.innerHTML = `
        <div class="flex justify-between items-start mb-4">
            <div class="text-sm font-bold ${roundTextColor}">
                ${question.id.startsWith('TB-') ? '决胜局 (Tiebreaker)' : `第 ${currentRound} 轮`}: ${question.id}
            </div>
            <div class="text-3xl font-extrabold text-red-400">
                ${question.points} 分
            </div>
        </div>
        ${questionContent}
        ${answerContent}
    `;

    // --- Score Adjustment Controls ---
    const controlsHtml = teams.filter(t => !t.eliminated).map(team => {
        const teamStatus = qStatus.teams.find(tStatus => tStatus.teamId === team.id);
        const isCorrect = teamStatus?.isCorrect || false;
        const buttonClass = isCorrect ? 'bg-green-500 hover:bg-green-600' : 'bg-gray-600 hover:bg-gray-500';

        return `
            <div class="flex items-center justify-between p-2 rounded-lg bg-gray-700/50">
                <span class="font-semibold text-sm ${team.color.replace('bg-', 'text-')}">${team.name}</span>
                <div class="flex items-center space-x-2">
                    <span class="text-sm font-bold text-gray-200 w-8 text-right">${teamStatus?.points || 0}</span>
                    <button onclick="applyScore('${team.id}', true, ${questionIndex})"
                            class="${buttonClass} text-white px-3 py-1 rounded text-xs font-bold transition duration-150">
                        ${isCorrect ? '✔ 已得分' : '得分'}
                    </button>
                    <button onclick="removeScore('${team.id}', ${questionIndex})"
                            class="bg-red-700/50 hover:bg-red-700 text-white px-3 py-1 rounded text-xs font-bold transition duration-150">
                        取消
                    </button>
                </div>
            </div>
        `;
    }).join('');

    controls.innerHTML = `
        <h3 class="text-lg font-bold text-gray-300 mb-3 border-b border-gray-700 pb-2">团队得分管理 (${question.points}分)</h3>
        <div class="space-y-2">
            ${controlsHtml}
        </div>
    `;
}

/**
 * Loads a question by its index, updates the UI, and saves state.
 * @param {number} index The index of the question to load (-1 for welcome screen).
 */
function loadQuestion(index) {
    if (index < -1 || index >= geographyQuestions.length) return;

    currentQuestionIndex = index;
    saveCurrentIndex();

    renderQuestionPanel(currentQuestionIndex);
    renderQuestionNavigation(currentQuestionIndex);

    // If we moved to a new question, ensure score controls are visible
    if (currentQuestionIndex !== -1) {
        document.getElementById('scoreAdjustmentControls').classList.remove('hidden');
    }
}

/**
 * Moves to the next question.
 */
function nextQuestion() {
    loadQuestion(currentQuestionIndex + 1);
}

/**
 * Moves to the previous question.
 */
function prevQuestion() {
    loadQuestion(currentQuestionIndex - 1);
}

/**
 * Starts the quiz by loading the first question.
 */
function startQuiz() {
    // Find the first question of Round 1
    const firstRound1Index = findFirstQuestionIndexForRound(1);
    if (firstRound1Index !== -1) {
        loadQuestion(firstRound1Index);
    } else {
        console.error("Could not find the start of Round 1 questions.");
    }
}

// --- UI Management and Status Update ---

/**
 * Toggles the visibility of the individual score adjustment panel.
 */
function toggleIndividualLeaderboard() {
    const individualPanel = document.getElementById('individualPanel');
    const isHidden = individualPanel.classList.contains('hidden');

    if (isHidden) {
        individualPanel.classList.remove('hidden');
        localStorage.setItem('showIndividualLeaderboard', 'true');
    } else {
        individualPanel.classList.add('hidden');
        localStorage.setItem('showIndividualLeaderboard', 'false');
    }
    updateLeaderboardToggleUI();
}

/**
 * Updates the text and state of the leaderboard toggle button.
 */
function updateLeaderboardToggleUI() {
    const individualPanel = document.getElementById('individualPanel');
    const toggleBtn = document.getElementById('toggleIndividualLeaderboardBtn');
    if (!individualPanel || !toggleBtn) return;

    const isHidden = individualPanel.classList.contains('hidden');
    toggleBtn.textContent = isHidden ? '显示个人得分' : '隐藏个人得分';
}

/**
 * Updates the round status buttons (Finish Round 1, 2, 3) based on game state.
 */
function updateRoundStatusUI() {
    const r1Btn = document.getElementById('finishRound1Btn');
    const r2Btn = document.getElementById('finishRound2Btn');
    const r3Btn = document.getElementById('finishRound3Btn');

    if (r1Btn) {
        r1Btn.disabled = roundState.isRound1Finished;
        r1Btn.classList.toggle('opacity-50', roundState.isRound1Finished);
        r1Btn.classList.toggle('cursor-not-allowed', roundState.isRound1Finished);
    }
    if (r2Btn) {
        r2Btn.disabled = roundState.isRound2Finished || !roundState.isRound1Finished;
        r2Btn.classList.toggle('opacity-50', r2Btn.disabled);
        r2Btn.classList.toggle('cursor-not-allowed', r2Btn.disabled);
    }
    if (r3Btn) {
        r3Btn.disabled = roundState.isRound3Finished || !roundState.isRound2Finished;
        r3Btn.classList.toggle('opacity-50', r3Btn.disabled);
        r3Btn.classList.toggle('cursor-not-allowed', r3Btn.disabled);
    }
}

/**
 * Resets the entire game state.
 */
function resetGame() {
    if (confirm('确认重置整个测验吗？所有分数和状态都将丢失。')) {
        // Clear all local storage keys
        localStorage.removeItem(LOCAL_STORAGE_KEY_TEAMS);
        localStorage.removeItem(LOCAL_STORAGE_KEY_QUESTION_STATUS);
        localStorage.removeItem(LOCAL_STORAGE_KEY_CURRENT_INDEX);
        localStorage.removeItem(LOCAL_STORAGE_KEY_ROUND_STATE);
        localStorage.removeItem(LOCAL_STORAGE_KEY_INDIVIDUALS);

        // Reinitialize everything
        currentQuestionIndex = -1;
        initializeQuestions();
        loadTeams();
        loadRoundState();
        loadIndividuals();
        loadQuestion(-1); // Display welcome state
        renderLeaderboard();
        renderIndividualLeaderboard();
        // REMOVED: renderScoreAdjustmentButtons(); // Removed non-existent function call
        updateRoundStatusUI();
        updateLeaderboardToggleUI();
    }
}

// --- Timer Functions ---
function startTimer() {
    if (timerInterval) return; // Timer is already running

    const timerValue = document.getElementById('timerValue');

    timeRemaining = 10;
    timerValue.textContent = timeRemaining;

    timerInterval = setInterval(() => {
        timeRemaining--;
        timerValue.textContent = timeRemaining;

        if (timeRemaining <= 0) {
            clearInterval(timerInterval);
            timerInterval = null;
            timeRemaining = 10;
            timerValue.textContent = timeRemaining;
            DING_AUDIO.play().catch(e => console.error("Audio play failed:", e));
        }
    }, 1000);
}

// --- Initialization ---

document.addEventListener('DOMContentLoaded', () => {
    // Load state
    loadTeams();
    loadRoundState();
    loadIndividuals();
    initializeQuestions();
    loadCurrentIndex();

    // Initial Render
    renderLeaderboard();
    renderIndividualLeaderboard();
    updateRoundStatusUI();

    // Load the current question/screen
    loadQuestion(currentQuestionIndex);

    // Initial check for individual leaderboard visibility
    const showIndividual = localStorage.getItem('showIndividualLeaderboard');
    const individualPanel = document.getElementById('individualPanel');
    if (individualPanel) {
        if (showIndividual === 'false') {
            individualPanel.classList.add('hidden');
        } else {
            individualPanel.classList.remove('hidden');
        }
    }
    updateLeaderboardToggleUI();

    // Ensure scores are correctly calculated on load (especially for bonuses)
    teams.forEach(t => t.score = calculateTeamScore(t.id));
    saveTeams();
    renderLeaderboard();
});
// --- Configuration and Data ---
const LOCAL_STORAGE_KEY_TEAMS = 'quizTeams';
const LOCAL_STORAGE_KEY_QUESTION_STATUS = 'quizQuestionStatus';
const LOCAL_STORAGE_KEY_CURRENT_INDEX = 'quizCurrentIndex';
const LOCAL_STORAGE_KEY_ROUND_STATE = 'quizRoundStateV1';
const LOCAL_STORAGE_KEY_INDIVIDUALS = 'quizIndividualsV1';

// Full set of quiz questions loaded from the user's document
// -------------------------------------------------------------------
const geographyQuestions = [
    {
        id: "R1-MC-001",
        type: "multiple-choice",
        text: "以下哪个城市不是中国的四个直辖市之一？",
        options: ["A.上海", "B.天津", "C.重庆", "D.深圳"],
        answer: "D",
        points: 1,
        rationale: "中国四个直辖市分别是：上海、天津、重庆、北京。深圳是经济特区。",
    },
    {
        id: "R1-MC-002",
        type: "multiple-choice",
        text: "以下哪个海域不是中国的四大海域之一？",
        options: ["A.东海", "B.洱海", "C.黄海", "D.渤海"],
        answer: "B",
        points: 1,
        rationale: "中国四大海域为渤海、黄海、东海、南海。洱海是云南的湖泊。",
    },
    {
        id: "R1-MC-003",
        type: "multiple-choice",
        text: "以下哪个国家不在两河流域？",
        options: ["A.叙利亚", "B.伊拉克", "C.亚美尼亚", "D.土耳其"],
        answer: "C",
        points: 1,
        rationale: "“两河”指底格里斯河和幼发拉底河，不流经亚美尼亚。",
    },
    {
        id: "R1-MC-004",
        type: "multiple-choice",
        text: "以下哪个不是英国的构成国之一？",
        options: ["A.苏格兰", "B.北爱尔兰", "C.设得兰", "D.英格兰"],
        answer: "C",
        points: 1,
        rationale: "英国的构成国是英格兰、威尔士、苏格兰和北爱尔兰。设得兰是一个群岛的名字。",
    },
    {
        id: "R1-MC-005",
        type: "multiple-choice",
        text: "以下哪个国家不被赤道穿过？",
        options: ["A.阿尔及利亚", "B.厄瓜多尔", "C.印度尼西亚", "D.马尔代夫"],
        answer: "A",
        points: 1,
        rationale: "赤道大致穿过非洲中部，阿尔及利亚位于北非，不被赤道穿过。",
    },
    {
        id: "R1-MC-006",
        type: "multiple-choice",
        text: "以下哪个不是古代世界四大文明之一？",
        options: ["A.古巴比伦", "B.古罗马", "C.古埃及", "D.古印度"],
        answer: "B",
        points: 1,
        rationale: "古代世界四大文明是古埃及、古巴比伦、古印度和古中国。古罗马是西方文明的重要组成部分，但通常不列入“四大文明古国”。",
    },
    {
        id: "R1-MC-007",
        type: "multiple-choice",
        text: "直布罗陀是哪个国家的海外领土？",
        options: ["A.爱尔兰", "B.法国", "C.西班牙", "D.英国"],
        answer: "D",
        points: 3,
        rationale: "1713年的《乌得勒支和约》将直布罗陀转让给了英国统治。",
    },
    {
        id: "R1-MC-008",
        type: "multiple-choice",
        text: "以下哪个国家没有被英国殖民过？",
        options: ["A.伊朗", "B.埃及", "C.爱尔兰", "D.赞比亚"],
        answer: "A",
        points: 3,
        rationale: "伊朗（波斯）从未被任何西方国家正式殖民过，而埃及、爱尔兰和赞比亚（北罗德西亚）都曾是英国殖民地或保护国。",
    },
    {
        id: "R1-MC-009",
        type: "multiple-choice",
        text: "南美洲唯一一个在太平洋和加勒比海沿岸都有海岸线的国家是？",
        options: ["A.巴拉圭", "B.巴西", "C.哥伦比亚", "D.智利"],
        answer: "C",
        points: 3,
        rationale: "哥伦比亚是南美洲唯一一个同时拥有太平洋和加勒比海海岸线的国家。",
    },
    {
        id: "R1-MC-010",
        type: "multiple-choice",
        text: "下列哪座山是神话传说中众神居住之所？",
        options: ["A.勃朗峰", "B.奥林匹斯山", "C.马特洪峰", "D.厄尔布鲁士山"],
        answer: "B",
        points: 3,
        rationale: "希腊神话中，奥林匹斯山（Mount Olympus）是众神的居所。",
    },
    {
        id: "R1-MC-011",
        type: "multiple-choice",
        text: "巴基斯坦的首都是下列哪个城市？",
        options: ["A.卡拉奇", "B.比什凯克", "C.班加罗尔", "D.伊斯兰堡"],
        answer: "D",
        points: 3,
        rationale: "巴基斯坦的首都是伊斯兰堡。卡拉奇是人口最多的城市；比什凯克是吉尔吉斯斯坦的首都；班加罗尔是印度的城市。",
    },
    {
        id: "R1-MC-012",
        type: "multiple-choice",
        text: "“石油输出国组织”的英文简称是？",
        options: ["A.UNESCO", "B.OPEC", "C.ASEAN", "D.AU"],
        answer: "B",
        points: 3,
        rationale: "OPEC 代表“The Organization of the Petroleum Exporting Countries”（石油输出国组织）。",
    },
    {
        id: "R1-MC-013",
        type: "multiple-choice",
        text: "世界上最“年轻”的国家是？",
        options: ["A.南苏丹", "B.东帝汶", "C.黑山", "D.马绍尔群岛"],
        answer: "A",
        points: 5,
        rationale: "南苏丹于2011年7月9日从苏丹独立，是世界上最年轻的国家。",
    },
    {
        id: "R1-MC-014",
        type: "multiple-choice",
        text: "底特律位于美国哪个州？",
        options: ["A.密歇根州", "B.堪萨斯州", "C.威斯康星州", "D.伊利诺伊州"],
        answer: "A",
        points: 5,
        rationale: "底特律位于密歇根州（Michigan），是该州最大的城市。",
    },
    {
        id: "R1-MC-015",
        type: "multiple-choice",
        text: "世界七大奇迹之一的罗德岛太阳神铜像曾经位于现在哪国领土？",
        options: ["A.塞浦路斯", "B.土耳其", "C.希腊", "D.埃及"],
        answer: "C",
        points: 5,
        rationale: "罗德岛太阳神铜像曾经矗立在希腊罗得岛上的罗得港港口。",
    },
    {
        id: "R1-MC-016",
        type: "multiple-choice",
        text: "根据BBC报道，2025年10月22日尼日利亚的一起油罐车爆炸事故造成了至少42人死亡。下列哪个是尼日利亚的国旗？",
        options: [
            "A. ",
            "B. ",
            "C. ",
            "D. "
        ],
        answer: "C",
        points: 5,
        rationale: "尼日利亚国旗是绿白绿三色垂直条纹。选项A是塞内加尔国旗，B是贝宁国旗，D是埃塞俄比亚国旗。",
        // Note: The images are placeholders here, as external image data for flags
        // cannot be reliably included in this format without a direct URL.
    },
    {
        id: "R1-MC-017",
        type: "multiple-choice",
        text: "马达加斯加岛的标志性物种是？",
        options: ["A.玳瑁", "B.狐猴", "C.旋角羚", "D.土豚"],
        answer: "B",
        points: 5,
        rationale: "所有狐猴（Lemur）均原生于马达加斯加的丛林中，是该岛的标志性物种。",
    },
    {
        id: "R1-MC-018",
        type: "multiple-choice",
        text: "以下哪个不是意大利的城市？",
        options: ["A.佩斯卡拉", "B.帕尔马", "C.巴勒莫", "D.里耶卡"],
        answer: "D",
        points: 5,
        rationale: "里耶卡（Rijeka）是克罗地亚的城市。佩斯卡拉、帕尔马和巴勒莫都是意大利的城市。",
    },
    // --- 抢答选择题 (Rapid Fire Multiple Choice) ---
    {
        id: "R2-MC-001",
        type: "multiple-choice",
        text: "世界上陆地面积第二小的大洲是？",
        options: ["A.欧洲", "B.非洲", "C.南美洲", "D.北美洲"],
        answer: "A",
        points: 1, // Assuming points remain 1 for simplicity here, as they were rapid fire
        rationale: "世界上陆地面积最小的大洲是大洋洲，倒数第二是欧洲，面积约为1053万平方千米。",
    },
    {
        id: "R2-MC-002",
        type: "multiple-choice",
        text: "以下哪个海域不在亚洲？",
        options: ["A.波斯湾", "B.濑户内海", "C.亚德里亚海", "D.萨武海"],
        answer: "C",
        points: 1,
        rationale: "亚德里亚海大致位于意大利和巴尔干半岛之间，属于欧洲海域。",
    },
    {
        id: "R2-MC-003",
        type: "multiple-choice",
        text: "以下哪个不是印度尼西亚的岛屿？",
        options: ["A.棉兰老岛", "B.苏门答腊岛", "C.爪哇岛", "D.婆罗洲（加里曼丹岛）"],
        answer: "A",
        points: 1,
        rationale: "棉兰老岛是菲律宾的第二大岛。苏门答腊岛、爪哇岛和婆罗洲（加里曼丹岛）都是印度尼西亚的主要岛屿。",
    },
    {
        id: "R2-MC-004",
        type: "multiple-choice",
        text: "以下哪个国家不被阿尔卑斯山脉穿过？",
        options: ["A.法国", "B.斯洛文尼亚", "C.意大利", "D.斯洛伐克"],
        answer: "D",
        points: 1,
        rationale: "斯洛伐克的主要山脉是喀尔巴阡山脉，阿尔卑斯山脉不穿过斯洛伐克。",
    },
    {
        id: "R2-MC-005",
        type: "multiple-choice",
        text: "以下哪个不是东南亚国家？",
        options: ["A.缅甸", "B.文莱", "C.孟加拉国", "D.东帝汶"],
        answer: "C",
        points: 1,
        rationale: "孟加拉国在地理区域的划分上属于南亚国家。",
    },
    // --- 加赛抢答 (Overtime Rapid Fire) ---
    {
        id: "R3-MC-001",
        type: "multiple-choice",
        text: "伊斯兰教在以下哪个国家不是主要宗教？",
        options: ["A.阿尔及利亚", "B.以色列", "C.印度尼西亚", "D.阿曼"],
        answer: "B",
        points: 1,
        rationale: "阿尔及利亚、印度尼西亚和阿曼都有约90%及以上人口信奉伊斯兰教。以色列的主要宗教是犹太教。",
    },
    {
        id: "R3-MC-002",
        type: "multiple-choice",
        text: "南美洲国家大多以哪种语言作为官方语言？",
        options: ["A.西班牙语", "B.葡萄牙语", "C.英语", "D.克里奥尔语"],
        answer: "A",
        points: 1,
        rationale: "南美洲的12个国家中有9个使用西班牙语作为官方语言，这与西班牙历史上对该地区的殖民有重大关系。",
    },
    {
        id: "R3-MC-003",
        type: "multiple-choice",
        text: "地球的“年龄”大约是？",
        options: ["A.80亿年", "B.45亿年", "C.55亿年", "D.24亿年"],
        answer: "B",
        points: 1,
        rationale: "地球的年龄约为45.4亿年，四舍五入得45亿年。",
    },
    {
        id: "R3-MC-004",
        type: "multiple-choice",
        text: "世界上最古老的国家公园是？",
        options: ["A.大沼泽地国家公园", "B.阿卡迪亚国家公园", "C.黄石国家公园", "D.大峡谷国家公园"],
        answer: "C",
        points: 1,
        rationale: "美国黄石国家公园建立于1872年3月1日，是世界上第一座国家公园。",
    },
];
// -------------------------------------------------------------------

let teams = [];
let questions = [];
let currentQuestionIndex = -1;
let roundState = null;
let individuals = [];
let leaderboardView = 'team'; // 'team' | 'individual'
let fragmentPanels = [];
let fragmentObserver = null;
let fragmentRefreshScheduled = false;
let timerInterval = null;
let timeRemaining = 10;

// --- Initialization and Core Logic ---

document.addEventListener('DOMContentLoaded', () => {
    initializeQuestions();
    loadTeams();
    loadRoundState();
    loadIndividuals();
    renderLeaderboard();
    renderIndividualLeaderboard();
    // Removed: renderScoreAdjustmentButtons(); // Redundant function call
    loadCurrentState();
    updateRoundStatusUI();
    updateLeaderboardToggleUI();
    setPanelHeights();
    window.addEventListener('resize', setPanelHeights);
    initPanelBackgroundFragments();

    // Add Enter key support for team input
    const teamInput = document.getElementById('newTeamName');
    if (teamInput) {
        teamInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                addTeam();
            }
        });
    }
});

function setPanelHeights() {
    const questionCard = document.getElementById('question-card-sizer');
    if (questionCard) {
        const height = questionCard.offsetHeight;
        document.documentElement.style.setProperty('--question-card-height', `${height}px`);
    }
}

function initializeQuestions() {
    // Load questions from the embedded data and initialize status
    const status = JSON.parse(localStorage.getItem(LOCAL_STORAGE_KEY_QUESTION_STATUS) || '[]');

    questions = geographyQuestions.map((q, index) => {
        const existingStatus = status.find(s => s.id === q.id);
        return {
            ...q,
            numeric_id: index, // Keep a numeric index for navigation
            isAnswered: existingStatus ? existingStatus.isAnswered : false,
            isRevealed: existingStatus ? existingStatus.isRevealed : false,
        };
    });
}

function loadTeams() {
    // Load teams from Local Storage. Initialize to empty array if none exist.
    try {
        const raw = localStorage.getItem(LOCAL_STORAGE_KEY_TEAMS);
        teams = raw ? JSON.parse(raw) : [];
    } catch (e) {
        console.error("Error loading teams from local storage:", e);
        teams = [];
    }

    // Ensure teams is always an array
    if (!Array.isArray(teams)) {
        teams = [];
    }
}

function saveTeams() {
    // Save teams to Local Storage
    teams.sort((a, b) => b.score - a.score); // Sort by score descending
    localStorage.setItem(LOCAL_STORAGE_KEY_TEAMS, JSON.stringify(teams));
    renderLeaderboard();
    // Removed: renderScoreAdjustmentButtons(); // Redundant function call
}

function saveQuestionStatus() {
    // Save only the necessary status fields
    const statusToSave = questions.map(q => ({
        id: q.id, // Use original string ID for stable storage
        isAnswered: q.isAnswered,
        isRevealed: q.isRevealed,
    }));
    localStorage.setItem(LOCAL_STORAGE_KEY_QUESTION_STATUS, JSON.stringify(statusToSave));
}

// --- Round & Mode State ---
function getDefaultRoundState() {
    return {
        currentRound: 1,
        mode: 'team', // 'team' | 'individual'
        isFinishedRound1: false,
        isFinishedRound2: false,
        isFinishedRound3: false,
        quizFinished: false,
        eliminatedTeamIds: [],
        individualRosterLocked: false,
        finalBonuses: {},
    };
}

function loadRoundState() {
    const raw = localStorage.getItem(LOCAL_STORAGE_KEY_ROUND_STATE);
    if (raw) {
        try {
            roundState = JSON.parse(raw);
        } catch {
            roundState = getDefaultRoundState();
        }
    } else {
        roundState = getDefaultRoundState();
    }
}

function saveRoundState() {
    localStorage.setItem(LOCAL_STORAGE_KEY_ROUND_STATE, JSON.stringify(roundState));
    updateRoundStatusUI();
    updateLeaderboardToggleUI();
}

function loadCurrentState() {
    const index = localStorage.getItem(LOCAL_STORAGE_KEY_CURRENT_INDEX);
    if (index !== null) {
        loadQuestion(parseInt(index), false); // false = do not reset state immediately
    }
    // When no current question stored, keep welcome screen but ensure score panel/buttons reflect mode
    if (index === null) {
        loadQuestion(-1);
    }
}

function saveCurrentIndex(index) {
    localStorage.setItem(LOCAL_STORAGE_KEY_CURRENT_INDEX, index);
}

// --- Individuals (Round 3) ---
function loadIndividuals() {
    const raw = localStorage.getItem(LOCAL_STORAGE_KEY_INDIVIDUALS);
    if (raw) {
        try {
            individuals = JSON.parse(raw);
        } catch {
            individuals = [];
        }
    } else {
        individuals = [];
    }
}

function saveIndividuals() {
    localStorage.setItem(LOCAL_STORAGE_KEY_INDIVIDUALS, JSON.stringify(individuals));
    renderIndividualLeaderboard();
}

// --- Team Management Functions ---
function toggleTeamManagement() {
    const panel = document.getElementById('teamManagementPanel');
    panel.classList.toggle('hidden');
}

function addTeam() {
    const input = document.getElementById('newTeamName');
    if (!input) return;

    const name = input.value.trim();
    if (name) {
        // Ensure teams is an array before pushing
        if (!Array.isArray(teams)) teams = [];

        // Calculate new ID safely
        const newId = teams.length > 0 ? Math.max(...teams.map(t => t.id || 0)) + 1 : 1;

        teams.push({ id: newId, name: name, score: 0 });
        input.value = '';
        saveTeams(); // This calls renderLeaderboard() which displays the new team
    }
}

function removeSelectedTeam() {
    const selector = document.getElementById('teamSelector');
    const teamIdToRemove = parseInt(selector.value);
    if (teamIdToRemove && !isNaN(teamIdToRemove)) {
        teams = teams.filter(t => t.id !== teamIdToRemove);
        selector.value = '';
        saveTeams();
    }
}

function renderLeaderboard() {
    const leaderboardList = document.getElementById('leaderboardList');
    const teamSelector = document.getElementById('teamSelector');
    const individualPanel = document.getElementById('individualLeaderboardPanel');

    // Toggle visibility based on current view
    if (leaderboardView === 'team') {
        leaderboardList.parentElement.parentElement.classList.remove('hidden');
        if (individualPanel) individualPanel.classList.add('hidden');
    }

    // Render Team Leaderboard
    if (teams.length === 0) {
        leaderboardList.innerHTML = `
            <tr class="team-row">
                <td colspan="3" class="px-3 py-4 text-center text-gray-500">
                    No teams added yet. Use 'Manage Teams' to start!
                </td>
            </tr>
        `;
    } else {
        const isAnswerRevealed = currentQuestionIndex > -1 && questions[currentQuestionIndex].isRevealed;
        leaderboardList.innerHTML = teams.map((team, index) => {
            const isTopTeam = index === 0 && team.score > 0;

            // FIX START: Safely access eliminatedTeamIds, defaulting to an empty array if missing.
            const eliminatedIds = (roundState && roundState.eliminatedTeamIds) || [];
            const isEliminated = eliminatedIds.includes(team.id);
            // FIX END

            const scoreClass = isTopTeam
                ? 'text-xl font-extrabold text-green-600'
                : 'text-lg font-semibold';
            const rowColor = isEliminated
                ? 'bg-red-50 dark:bg-red-900/40'
                : (roundState && roundState.currentRound >= 3 ? 'bg-green-50 dark:bg-green-900/30' : '');
            let rankIcon = index + 1;
            if (isTopTeam) rankIcon = '🥇';
            else if (index === 1) rankIcon = '🥈';
            else if (index === 2) rankIcon = '🥉';

            const disabledAttr = isEliminated ? 'disabled' : '';
            const buttonClass = isEliminated ? 'text-gray-300 dark:text-gray-600 cursor-not-allowed' : 'hover:scale-125 transition-transform';

            return `
                <tr class="team-row hover:bg-gray-50 dark:hover:bg-gray-700 transition duration-150 ${rowColor}">
                    <td class="px-3 py-4 whitespace-nowrap text-sm font-medium text-gray-900 dark:text-gray-100">${rankIcon}</td>
                    <td class="px-3 py-4 whitespace-nowrap text-lg font-medium text-indigo-600 dark:text-indigo-400">${team.name}</td>
                    <td id="score-${team.id}" class="px-3 py-4 whitespace-nowrap ${scoreClass}">${team.score}</td>
                    <td class="px-3 py-4 whitespace-nowrap text-center">
                        <button onclick="addScore(${team.id})" class="font-bold text-xl text-green-500 hover:text-green-700 ${buttonClass}" ${disabledAttr}>+</button>
                        <button onclick="subtractScore(${team.id})" class="font-bold text-xl text-red-500 hover:text-red-700 ml-2 ${buttonClass}" ${disabledAttr}>-</button>
                    </td>
                </tr>
            `;
        }).join('');
    }


    // Render Remove Team Selector
    teamSelector.innerHTML = '<option value="" disabled selected>Select team to remove</option>' + teams.map(team => `
        <option value="${team.id}">${team.name}</option>
    `).join('');
}

function loadQuestion(index, resetState = true) {
    if (index < 0 || index >= questions.length) {
        currentQuestionIndex = -1;
        saveCurrentIndex(-1);
        document.getElementById('questionTitle').textContent = "Welcome to the Quiz Master!";
        document.getElementById('questionContent').textContent = "Use the button below to load the next question once teams are ready.";
        document.getElementById('optionsContainer').classList.add('hidden');
        document.getElementById('correctAnswer').textContent = "(Answer is hidden)";
        document.getElementById('revealBtn').style.display = 'none';
        const nextBtn = document.getElementById('nextBtn');
        nextBtn.style.display = 'inline-block';
        nextBtn.textContent = "LOAD NEXT QUESTION »";
        document.getElementById('scorePanel').style.display = 'none';
        return;
    }

    currentQuestionIndex = index;
    saveCurrentIndex(index);
    const q = questions[index];

    document.getElementById('questionCard').classList.remove('flash-effect-reveal');
    document.getElementById('scorePanel').style.display = 'none';

    // Reset reveal state if moving to a new question (unless explicitly prevented)
    if (resetState) {
        q.isRevealed = false;
        saveQuestionStatus();
    }

    // Update Question Card
    document.getElementById('questionTitle').textContent = `Question ${q.id} (${q.points} Points)`;
    document.getElementById('questionContent').textContent = q.text; // Use 'text' instead of 'question'
    document.getElementById('currentPoints').textContent = q.points;
    document.getElementById('correctAnswer').textContent = q.isRevealed ? `${q.answer}. ${q.rationale}` : "(Answer is hidden)";


    // Update Options
    const optionsContainer = document.getElementById('optionsContainer');
    optionsContainer.innerHTML = '';
    if (q.type === 'multiple-choice' && q.options) { // Check for 'multiple-choice'
        optionsContainer.classList.remove('hidden');
        optionsContainer.innerHTML = q.options.map(option => {
            // Answer is a letter like "D", option is "D.深圳". Check if option starts with the answer letter.
            const isAnswer = q.isRevealed && option.startsWith(q.answer + ".");
            const optionClass = isAnswer
                ? 'bg-green-100 dark:bg-green-700 border-green-500 font-bold text-green-800 dark:text-green-100 shadow-lg'
                : 'bg-gray-50 dark:bg-gray-700 border-gray-300 font-medium text-gray-700 dark:text-gray-200 shadow-md';
            return `
                <div class="p-3 border-l-4 rounded-lg ${optionClass} transition duration-300">
                    ${option}
                </div>
            `;
        }).join('');
    } else {
        optionsContainer.classList.add('hidden');
    }

    // Update Buttons and Score Panel Visibility
    document.getElementById('revealBtn').style.display = q.isRevealed ? 'none' : 'inline-block';
    const nextBtn = document.getElementById('nextBtn');
    nextBtn.textContent = "NEXT QUESTION »";
    nextBtn.style.display = q.isRevealed ? 'inline-block' : 'none';
    if (q.isRevealed) {
        document.getElementById('scorePanel').style.display = 'block';
    }
    renderLeaderboard(); // Update buttons in leaderboard
}

function findNextUnanswered(startIndex = -1) {
    for (let i = startIndex + 1; i < questions.length; i++) {
        if (!questions[i].isAnswered) {
            return i;
        }
    }
    return -1;
}

function showCompletionState() {
    currentQuestionIndex = -1;
    saveCurrentIndex(-1);
    document.getElementById('questionTitle').textContent = "Quiz Complete!";
    document.getElementById('questionContent').textContent = "All questions have been answered. You can still adjust scores if needed or reset to start over.";
    document.getElementById('optionsContainer').classList.add('hidden');
    document.getElementById('correctAnswer').textContent = "(Quiz Finished)";
    document.getElementById('revealBtn').style.display = 'none';
    const nextBtn = document.getElementById('nextBtn');
    nextBtn.style.display = 'none';
    document.getElementById('scorePanel').style.display = 'none';
}

function revealAnswer() {
    if (currentQuestionIndex === -1) return;

    const q = questions[currentQuestionIndex];
    if (q.isRevealed) return;

    // 1. Set revealed state
    q.isRevealed = true;
    saveQuestionStatus();

    // 2. Animate and display answer
    const questionCard = document.getElementById('questionCard');
    questionCard.classList.add('flash-effect-reveal'); // Trigger the flash animation
    questionCard.addEventListener('animationend', function handler() {
        // Remove the class after animation to allow the card to return to default color
        questionCard.classList.remove('flash-effect-reveal');
        questionCard.removeEventListener('animationend', handler);
    });

    // Display the answer and update UI
    document.getElementById('correctAnswer').textContent = `${q.answer}. ${q.rationale}`;
    document.getElementById('revealBtn').style.display = 'none';
    document.getElementById('nextBtn').style.display = 'inline-block';
    document.getElementById('scorePanel').style.display = 'block';

    // Re-render question to show correct options/styling
    loadQuestion(currentQuestionIndex, false);
}

function goToNextQuestion() {
    if (currentQuestionIndex === -1) {
        const nextIndex = findNextUnanswered(-1);
        if (nextIndex === -1) {
            showCompletionState();
        } else {
            loadQuestion(nextIndex);
        }
        return;
    }

    const q = questions[currentQuestionIndex];
    if (!q.isRevealed) {
        return;
    }

    q.isAnswered = true;
    q.isRevealed = true;
    saveQuestionStatus();

    const nextIndex = findNextUnanswered(currentQuestionIndex);
    if (nextIndex === -1) {
        showCompletionState();
    } else {
        loadQuestion(nextIndex);
    }
}

function subtractScore(teamId) {
    if (!roundState || roundState.quizFinished) return;
    if (roundState.mode === 'individual') return; // Only team scoring here

    const eliminated = new Set(roundState.eliminatedTeamIds || []);
    if (eliminated.has(teamId)) return;

    // Default to 1 point if on welcome screen so you can test buttons
    const points = currentQuestionIndex === -1 ? 1 : questions[currentQuestionIndex].points;
    const team = teams.find(t => t.id === teamId);

    if (team) {
        const oldScore = team.score;
        team.score = Math.max(0, team.score - points); // Prevent negative scores
        saveTeams();
        animateScoreUpdate(`score-${team.id}`, oldScore, team.score);
        showAvatarFeedback(false); // Wrong answer feedback
    }
}

function addScore(teamId) {
    if (!roundState || roundState.quizFinished) return;
    if (roundState.mode === 'individual' && roundState.currentRound === 3) return;

    const eliminated = new Set(roundState.eliminatedTeamIds || []);
    if (eliminated.has(teamId)) return;

    // Default to 1 point if on welcome screen so you can test buttons
    const points = currentQuestionIndex === -1 ? 1 : questions[currentQuestionIndex].points;
    const team = teams.find(t => t.id === teamId);

    if (team) {
        const oldScore = team.score;
        team.score += points;
        saveTeams();
        animateScoreUpdate(`score-${team.id}`, oldScore, team.score);
        showAvatarFeedback(true); // Correct answer feedback
    }
}

function animateScoreUpdate(elementId, startScore, endScore, isBonus = false) {
    const element = document.getElementById(elementId);
    if (!element) return;

    const duration = isBonus ? 700 : 500; // Longer duration for bonus
    const frameDuration = 1000 / 60; // 60fps
    const totalFrames = Math.round(duration / frameDuration);
    let frame = 0;

    const countUp = () => {
        frame++;
        const progress = frame / totalFrames;
        const currentScore = Math.round(startScore + (endScore - startScore) * progress);
        element.textContent = currentScore;

        if (frame < totalFrames) {
            requestAnimationFrame(countUp);
        } else {
            element.textContent = endScore; // Ensure it ends on the exact score
        }
    };

    const animationClass = isBonus ? 'bonus-burst-effect' : 'score-update-effect';
    element.classList.add(animationClass);
    element.addEventListener('animationend', function handler() {
        element.classList.remove(animationClass);
        element.removeEventListener('animationend', handler);
    });

    requestAnimationFrame(countUp);
}

// --- Avatar Feedback ---
function showAvatarFeedback(isCorrect) {
    const image = document.getElementById('avatarImage');
    if (!image) return;

    // Set the correct image (thumb_up.gif or shocked.gif)
    image.src = isCorrect ? 'thumb_up.gif' : 'shocked.gif';

    // After 3 seconds, revert to idle.gif
    setTimeout(() => {
        image.src = 'idle.gif';
    }, 2400); // 3-second duration
}

// --- Round & leaderboard UI helpers ---
function updateRoundStatusUI() {
    const label = document.getElementById('roundStatus');
    const r1Btn = document.getElementById('finishRound1Btn');
    const r2Btn = document.getElementById('finishRound2Btn');
    const r3Btn = document.getElementById('finishRound3Btn');

    if (!roundState) return;

    if (label) {
        let text = `Round ${roundState.currentRound} · ${roundState.mode === 'individual' ? 'Individual Mode' : 'Team Mode'}`;
        if (roundState.quizFinished) text = 'Quiz Finished';
        label.textContent = text;
    }

    if (r1Btn) r1Btn.disabled = roundState.currentRound !== 1 || roundState.isFinishedRound1;
    if (r2Btn) r2Btn.disabled = roundState.currentRound !== 2 || !roundState.isFinishedRound1 || roundState.isFinishedRound2;
    if (r3Btn) r3Btn.disabled = roundState.currentRound !== 3 || !roundState.isFinishedRound2 || roundState.isFinishedRound3;
}

function updateLeaderboardToggleUI() {
    const teamBtn = document.getElementById('teamViewBtn');
    const indBtn = document.getElementById('individualViewBtn');
    const teamTableWrapper = document.getElementById('leaderboardList')?.parentElement?.parentElement;
    const individualPanel = document.getElementById('individualLeaderboardPanel');

    if (!roundState) return;

    // Force team view while still in team mode
    if (roundState.mode === 'team') {
        leaderboardView = 'team';
    }

    if (teamBtn && indBtn) {
        if (leaderboardView === 'team') {
            teamBtn.classList.add('bg-indigo-500', 'text-white');
            teamBtn.classList.remove('bg-gray-100', 'dark:bg-gray-800', 'text-gray-700', 'dark:text-gray-200');
            indBtn.classList.add('bg-gray-100', 'dark:bg-gray-800', 'text-gray-700', 'dark:text-gray-200');
            indBtn.classList.remove('bg-indigo-500', 'text-white');
        } else {
            indBtn.classList.add('bg-indigo-500', 'text-white');
            indBtn.classList.remove('bg-gray-100', 'dark:bg-gray-800', 'text-gray-700', 'dark:text-gray-200');
            teamBtn.classList.add('bg-gray-100', 'dark:bg-gray-800', 'text-gray-700', 'dark:text-gray-200');
            teamBtn.classList.remove('bg-indigo-500', 'text-white');
        }
    }

    if (teamTableWrapper && individualPanel) {
        if (leaderboardView === 'team') {
            teamTableWrapper.classList.remove('hidden');
            individualPanel.classList.add('hidden');
        } else {
            teamTableWrapper.classList.add('hidden');
            individualPanel.classList.remove('hidden');
        }
    }
}

function setLeaderboardView(view) {
    if (!roundState) return;
    if (roundState.mode === 'team' && view === 'individual') {
        // Can't view individuals before individual mode
        return;
    }
    leaderboardView = view === 'individual' ? 'individual' : 'team';
    updateLeaderboardToggleUI();
    renderLeaderboard();
    renderIndividualLeaderboard();
}

// --- Individuals: leaderboard + editor ---
function renderIndividualLeaderboard() {
    const tbody = document.getElementById('individualLeaderboardList');
    const panel = document.getElementById('individualLeaderboardPanel');
    if (!tbody || !panel) return;

    if (!individuals.length) {
        tbody.innerHTML = '<tr><td colspan="5" class="px-2 py-3 text-center text-gray-500 text-xs">No individuals yet. Finish Round 2 to generate roster.</td></tr>';
        renderIndividualEditor();
        return;
    }

    const teamMap = Object.fromEntries(teams.map(t => [t.id, t.name]));
    const indexMap = {};
    individuals.forEach((ind, idx) => { indexMap[ind.id] = idx; });

    const sorted = [...individuals].sort((a, b) =>
        b.score - a.score || indexMap[a.id] - indexMap[b.id]
    );

    const quizFinished = roundState && roundState.quizFinished;

    tbody.innerHTML = sorted.map((ind, index) => {
        let rankIcon = index + 1;
        if (index === 0) rankIcon = '🥇';
        else if (index === 1) rankIcon = '🥈';
        else if (index === 2) rankIcon = '🥉';

        const disabledAttr = quizFinished ? 'disabled' : '';
        const buttonClass = quizFinished ? 'text-gray-300 dark:text-gray-600 cursor-not-allowed' : 'hover:scale-125 transition-transform';

        return `
            <tr class="hover:bg-gray-50 dark:hover:bg-gray-700 transition duration-150">
                <td class="px-2 py-2 text-xs font-medium">${rankIcon}</td>
                <td class="px-2 py-2 text-xs">${ind.name}</td>
                <td class="px-2 py-2 text-xs text-indigo-600 dark:text-indigo-300">${teamMap[ind.teamId] || ''}</td>
                <td id="individual-score-${ind.id}" class="px-2 py-2 text-xs font-semibold">${ind.score}</td>
                <td class="px-2 py-2 whitespace-nowrap text-center">
                    <button onclick="addScoreIndividual('${ind.id}')" class="font-bold text-xl text-green-500 hover:text-green-700 ${buttonClass}" ${disabledAttr}>+</button>
                    <button onclick="subtractScoreIndividual('${ind.id}')" class="font-bold text-xl text-red-500 hover:text-red-700 ml-2 ${buttonClass}" ${disabledAttr}>-</button>
                </td>
            </tr>
        `;
    }).join('');

    renderIndividualEditor();
}

function renderIndividualEditor() {
    const editor = document.getElementById('individualEditor');
    const list = document.getElementById('individualEditorList');
    if (!editor || !list || !roundState) return;

    const shouldShow = roundState.currentRound === 3 && roundState.mode === 'individual' && !roundState.individualRosterLocked;
    if (!shouldShow) {
        editor.classList.add('hidden');
        return;
    }

    editor.classList.remove('hidden');
    list.innerHTML = individuals.map(ind => `
        <div class="flex items-center gap-1">
            <span class="w-8 text-[10px] text-gray-400">${ind.teamId}</span>
            <input type="text" data-id="${ind.id}" value="${ind.name}"
                   class="flex-1 px-1 py-0.5 border rounded text-xs bg-white dark:bg-gray-900" />
        </div>
    `).join('');
}

function lockIndividualRoster() {
    if (!roundState || roundState.individualRosterLocked) return;

    const inputs = document.querySelectorAll('#individualEditorList input[data-id]');
    inputs.forEach(input => {
        const id = input.dataset.id;
        const name = input.value.trim();
        const individual = individuals.find(ind => ind.id === id);
        if (individual && name) {
            individual.name = name;
        }
    });

    roundState.individualRosterLocked = true;
    saveRoundState();
    saveIndividuals();
    renderIndividualEditor();
    alertUser('Individual roster locked! You can now proceed with Round 3 questions.');
}

function generateIndividualRoster() {
    if (teams.length === 0) {
        alertUser("Please add teams first.");
        return;
    }

    individuals = [];
    let individualIdCounter = 1;
    for (const team of teams) {
        // Create 2 individuals per team
        individuals.push({
            id: `I-${individualIdCounter++}`,
            name: `${team.name} Player 1`,
            teamId: team.id,
            score: 0
        });
        individuals.push({
            id: `I-${individualIdCounter++}`,
            name: `${team.name} Player 2`,
            teamId: team.id,
            score: 0
        });
    }

    roundState.individualRosterLocked = false;
    saveIndividuals();
    renderIndividualLeaderboard();
    alertUser("Individual roster generated. Please review and rename players in the editor, then click 'Lock Roster'.");
}

function addScoreIndividual(individualId) {
    if (!roundState || roundState.quizFinished) return;
    if (roundState.mode === 'team') return;

    const points = currentQuestionIndex === -1 ? 1 : questions[currentQuestionIndex].points;
    const individual = individuals.find(i => i.id === individualId);

    if (individual) {
        const oldScore = individual.score;
        individual.score += points;
        saveIndividuals();
        animateScoreUpdate(`individual-score-${individual.id}`, oldScore, individual.score);
    }
}

function subtractScoreIndividual(individualId) {
    if (!roundState || roundState.quizFinished) return;
    if (roundState.mode === 'team') return;

    const points = currentQuestionIndex === -1 ? 1 : questions[currentQuestionIndex].points;
    const individual = individuals.find(i => i.id === individualId);

    if (individual) {
        const oldScore = individual.score;
        individual.score = Math.max(0, individual.score - points);
        saveIndividuals();
        animateScoreUpdate(`individual-score-${individual.id}`, oldScore, individual.score);
    }
}

// --- Round Finishing Logic ---
function finishRound(roundNum) {
    if (roundState.quizFinished) {
        alertUser("The quiz is already finished!");
        return;
    }

    if (roundNum === 1) {
        finishRound1();
    } else if (roundNum === 2) {
        finishRound2();
    } else if (roundNum === 3) {
        finishRound3();
    }
}

function finishRound1() {
    if (roundState.isFinishedRound1) {
        alertUser("Round 1 already finished.");
        return;
    }

    // Sort to identify lowest teams
    teams.sort((a, b) => a.score - b.score);

    // Identify the bottom two teams
    const teamsToEliminate = teams.slice(0, 2);

    if (teams.length < 3) {
        alertUser("Need at least 3 teams to eliminate two. Please add more teams or check scores.");
        return;
    }

    const eliminatedNames = teamsToEliminate.map(t => t.name).join(', ');
    const userConfirms = confirm(`Are you sure you want to finish Round 1 and eliminate the two lowest scoring teams: ${eliminatedNames}?`);

    if (userConfirms) {
        roundState.isFinishedRound1 = true;
        roundState.currentRound = 2;
        roundState.eliminatedTeamIds.push(...teamsToEliminate.map(t => t.id));

        // Re-sort teams by score descending for the leaderboard view
        teams.sort((a, b) => b.score - a.score);

        saveRoundState();
        saveTeams();
        loadQuestion(-1); // Go to welcome screen for Round 2 start
        alertUser(`Round 1 complete! Teams eliminated: ${eliminatedNames}. Starting Round 2.`);
    }
}

function finishRound2() {
    if (roundState.isFinishedRound2) {
        alertUser("Round 2 already finished.");
        return;
    }

    const activeTeams = teams.filter(t => !roundState.eliminatedTeamIds.includes(t.id));

    // Sort active teams to identify lowest team
    activeTeams.sort((a, b) => a.score - b.score);

    const teamToEliminate = activeTeams[0];

    if (activeTeams.length < 2) {
        alertUser("Need at least 2 active teams to eliminate one. Please check scores.");
        return;
    }

    const userConfirms = confirm(`Are you sure you want to finish Round 2 and eliminate the lowest scoring team: ${teamToEliminate.name}?`);

    if (userConfirms) {
        roundState.isFinishedRound2 = true;
        roundState.currentRound = 3;
        roundState.mode = 'individual'; // Switch to individual mode
        roundState.eliminatedTeamIds.push(teamToEliminate.id);

        // Prepare for individual round
        generateIndividualRoster();

        // Re-sort teams by score descending for the leaderboard view
        teams.sort((a, b) => b.score - a.score);

        saveRoundState();
        saveTeams();
        loadQuestion(-1); // Go to welcome screen for Round 3 start
        alertUser(`Round 2 complete! Team eliminated: ${teamToEliminate.name}. Starting Round 3 (Individual Mode).`);
    }
}

function finishRound3() {
    if (roundState.isFinishedRound3) {
        alertUser("Round 3 (Individual) already finished.");
        return;
    }

    if (!roundState.individualRosterLocked) {
        alertUser("Please lock the individual roster before finishing Round 3.");
        return;
    }

    const userConfirms = confirm("Are you sure you want to finish Round 3 and calculate final bonuses?");
    if (!userConfirms) return;

    // 1. Find top 3 individuals
    const sortedIndividuals = [...individuals].sort((a, b) => b.score - a.score);
    const topIndividuals = sortedIndividuals.slice(0, 3);

    // 2. Assign bonuses to their teams (if still active)
    roundState.finalBonuses = {};
    const bonusPoints = [15, 10, 5]; // 1st, 2nd, 3rd place bonus
    const activeTeamIds = new Set(teams.filter(t => !roundState.eliminatedTeamIds.includes(t.id)).map(t => t.id));

    let bonusSummary = 'Final Bonuses:\n';
    let teamUpdates = [];

    topIndividuals.forEach((individual, index) => {
        const team = teams.find(t => t.id === individual.teamId);
        const bonus = bonusPoints[index];

        if (team && activeTeamIds.has(team.id)) {
            const oldScore = team.score;
            team.score += bonus;
            roundState.finalBonuses[team.id] = (roundState.finalBonuses[team.id] || 0) + bonus;
            teamUpdates.push({ teamId: team.id, oldScore: oldScore, newScore: team.score, isBonus: true });
            bonusSummary += `${index + 1}st Individual (${individual.name}) earns ${bonus} points for Team ${team.name}.\n`;
        }
    });

    // 3. Finalize state
    roundState.isFinishedRound3 = true;
    roundState.quizFinished = true;
    teams.sort((a, b) => b.score - a.score); // Final sort

    saveRoundState();
    saveTeams();

    // 4. Animate bonuses and show final message
    const animationPromises = teamUpdates.map(update =>
        new Promise(resolve => {
            animateScoreUpdate(`score-${update.teamId}`, update.oldScore, update.newScore, update.isBonus);
            setTimeout(resolve, 800); // Wait for animation before next one/final message
        })
    );

    Promise.all(animationPromises).then(() => {
        const winner = teams.filter(t => !roundState.eliminatedTeamIds.includes(t.id))[0];
        alertUser(`Quiz Finished! Winner: ${winner ? winner.name : 'No active teams'}. \n${bonusSummary}`);
    });

    loadQuestion(-1); // Go to final completion screen
}


// --- Utility Functions ---

function alertUser(message) {
    // Custom modal/message box instead of alert()
    const modal = document.getElementById('alertModal');
    const msgContainer = document.getElementById('alertMessage');
    const closeBtn = document.getElementById('alertCloseBtn');

    if (!modal || !msgContainer || !closeBtn) {
        console.warn("Modal elements not found. Using console log for message:", message);
        console.log(message);
        return;
    }

    msgContainer.textContent = message;
    modal.classList.remove('hidden');

    // Automatically hide after 5 seconds
    const timeout = setTimeout(() => {
        modal.classList.add('hidden');
    }, 5000);

    // Manual close function
    const closeHandler = () => {
        modal.classList.add('hidden');
        clearTimeout(timeout);
        closeBtn.removeEventListener('click', closeHandler);
    };

    closeBtn.addEventListener('click', closeHandler);
}

function resetApp() {
    const userConfirms = confirm("Are you sure you want to completely reset the application? All teams, scores, and question statuses will be deleted.");
    if (userConfirms) {
        // Clear all local storage keys
        localStorage.removeItem(LOCAL_STORAGE_KEY_TEAMS);
        localStorage.removeItem(LOCAL_STORAGE_KEY_QUESTION_STATUS);
        localStorage.removeItem(LOCAL_STORAGE_KEY_CURRENT_INDEX);
        localStorage.removeItem(LOCAL_STORAGE_KEY_ROUND_STATE);
        localStorage.removeItem(LOCAL_STORAGE_KEY_INDIVIDUALS);

        // Reinitialize everything
        currentQuestionIndex = -1;
        initializeQuestions();
        loadTeams();
        loadRoundState();
        loadIndividuals();
        loadQuestion(-1); // Display welcome state
        renderLeaderboard();
        renderIndividualLeaderboard();
        // Removed: renderScoreAdjustmentButtons(); // Redundant function call
        updateRoundStatusUI();
        updateLeaderboardToggleUI();
    }
}

// --- Timer Functions ---
function startTimer() {
    if (timerInterval) return; // Timer is already running

    const timerValue = document.getElementById('timerValue');
    const bigBenContainer = document.getElementById('bigBenContainer');
    const bellSound = document.getElementById('bellSound');

    timeRemaining = 10;
    timerValue.textContent = timeRemaining;
    bigBenContainer.classList.add('timer-active');

    timerInterval = setInterval(() => {
        timeRemaining--;
        timerValue.textContent = timeRemaining;

        if (timeRemaining <= 3) {
            timerValue.classList.add('text-red-500', 'scale-125');
        } else {
            timerValue.classList.remove('text-red-500', 'scale-125');
        }

        if (timeRemaining <= 0) {
            clearInterval(timerInterval);
            timerInterval = null;
            timeRemaining = 10;
            timerValue.textContent = timeRemaining;
            timerValue.classList.remove('text-red-500', 'scale-125');
            bigBenContainer.classList.remove('timer-active');

            // Play a sound to signal time is up
            if (bellSound) bellSound.play().catch(e => console.error("Audio playback failed:", e));

            alertUser("TIME IS UP! Please lock in your answers.");
        }
    }, 1000);
}

// --- Background Fragments (Visual Effect) ---
function initPanelBackgroundFragments() {
    const fragments = [
        document.getElementById('fragmentPanel1'),
        document.getElementById('fragmentPanel2'),
        document.getElementById('fragmentPanel3')
    ].filter(el => el);

    fragmentPanels = fragments;

    if (fragmentPanels.length === 0) return;

    fragmentObserver = new ResizeObserver(entries => {
        if (!fragmentRefreshScheduled) {
            fragmentRefreshScheduled = true;
            window.requestAnimationFrame(() => {
                fragmentPanels.forEach(panel => createFragments(panel));
                fragmentRefreshScheduled = false;
            });
        }
    });

    fragmentPanels.forEach(panel => {
        fragmentObserver.observe(panel);
    });

    // Initial run
    fragmentPanels.forEach(panel => createFragments(panel));
}

function createFragments(panel) {
    // Clear existing fragments
    panel.innerHTML = '';
    const width = panel.offsetWidth;
    const height = panel.offsetHeight;

    // Define fragment size (e.g., 1/10th of the smaller dimension)
    const size = Math.min(width, height) / 8;
    const countX = Math.ceil(width / size);
    const countY = Math.ceil(height / size);

    // Total number of fragments, capped for performance
    const maxFragments = 150;
    const totalFragments = Math.min(countX * countY, maxFragments);

    // Only render fragments if we have space and it makes sense
    if (size < 10) return;

    for (let i = 0; i < totalFragments; i++) {
        const fragment = document.createElement('div');
        fragment.classList.add('absolute', 'bg-indigo-300', 'opacity-50', 'fragment');

        // Random size and position within bounds
        const s = size * (0.5 + Math.random() * 0.5); // Size variation
        const x = Math.random() * (width - s);
        const y = Math.random() * (height - s);

        fragment.style.width = `${s}px`;
        fragment.style.height = `${s}px`;
        fragment.style.left = `${x}px`;
        fragment.style.top = `${y}px`;
        fragment.style.borderRadius = '50%';
        fragment.style.filter = 'blur(10px)';
        fragment.style.animationDuration = `${5 + Math.random() * 5}s`; // 5 to 10 seconds
        fragment.style.animationDelay = `${-Math.random() * 10}s`; // Start at random phase

        panel.appendChild(fragment);
    }
}